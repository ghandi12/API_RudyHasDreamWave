#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Aug 02 23:51:03 2017 by generateDS.py version 2.28a.
#
# Command line options:
#   ('-o', 'c:\\Users\\cbpandey\\Downloads\\item.py')
#   ('-s', 'c:\\Users\\cbpandey\\Downloads\\itemsubs.py')
#
# Command line arguments:
#   Item.xsd
#
# Command line:
#   generateDS.py -o "c:\Users\cbpandey\Downloads\item.py" -s "c:\Users\cbpandey\Downloads\itemsubs.py" Item.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.28a0
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ItemCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, item=None):
        self.original_tagname_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemCollection.subclass:
            return ItemCollection.subclass(*args_, **kwargs_)
        else:
            return ItemCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def add_item(self, value): self.item.append(value)
    def insert_item_at(self, index, value): self.item.insert(index, value)
    def replace_item_at(self, index, value): self.item[index] = value
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ItemCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ItemCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ItemCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ItemCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ItemCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for item_ in self.item:
            item_.export(outfile, level, namespace_, name_='item', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'item':
            obj_ = ItemType.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class ItemCollection


class ItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, businessUnit=None, facility=None, number=None, name=None, classType=None, shortDescription=None, longDescription=None, dimension=None, itemWeight=None, abcCategory=None, productCode=None, originCountry=None, cycleCount=None, tradingPartner=None, purchaseCost=None, unitPrice=None, bornOnDateRequired=None, expirationDateRequired=None, receiveDateRequired=None, quarantineRequired=None, inspectionRequired=None, catchWeightRequired=None, hazmat=None, hazmatCode=None, intangibleItemFlag=None, inventoryTrackingEnabled=None, lotTrackingEnabled=None, serialTrackingEnabled=None, shippable=None, purchased=None, receiveOverTolerance=None, receiveUnderTolerance=None, cycleCountFrequency=None, reorderQuantity=None, accountingType=None, defaultLedgerAccount=None, cogsAccount=None, customFields=None, extendedEntities=None, channels=None, packs=None, upcs=None, productCategory=None, styleNumber=None, styleName=None, colorName=None, colorCode=None, size=None, nmfcNumber=None, harmonizedCode=None, mixLots=None, transportationClass=None, customMappings=None, components=None, itemVendors=None, customAttribute1=None, customAttribute2=None, customAttribute3=None, customAttribute4=None, customAttribute5=None, ule=None, uleUom=None, kitOrderOnly=None, kitStockOnly=None):
        self.original_tagname_ = None
        self.businessUnit = businessUnit
        self.facility = facility
        self.number = number
        self.name = name
        self.classType = classType
        self.shortDescription = shortDescription
        self.longDescription = longDescription
        self.dimension = dimension
        self.itemWeight = itemWeight
        self.abcCategory = abcCategory
        self.validate_abcCategoryType(self.abcCategory)
        self.productCode = productCode
        self.originCountry = originCountry
        self.cycleCount = cycleCount
        self.tradingPartner = tradingPartner
        self.purchaseCost = purchaseCost
        self.unitPrice = unitPrice
        self.bornOnDateRequired = bornOnDateRequired
        self.expirationDateRequired = expirationDateRequired
        self.receiveDateRequired = receiveDateRequired
        self.quarantineRequired = quarantineRequired
        self.inspectionRequired = inspectionRequired
        self.catchWeightRequired = catchWeightRequired
        self.hazmat = hazmat
        self.hazmatCode = hazmatCode
        self.intangibleItemFlag = intangibleItemFlag
        self.inventoryTrackingEnabled = inventoryTrackingEnabled
        self.lotTrackingEnabled = lotTrackingEnabled
        self.serialTrackingEnabled = serialTrackingEnabled
        self.shippable = shippable
        self.purchased = purchased
        self.receiveOverTolerance = receiveOverTolerance
        self.receiveUnderTolerance = receiveUnderTolerance
        self.cycleCountFrequency = cycleCountFrequency
        self.reorderQuantity = reorderQuantity
        self.accountingType = accountingType
        self.defaultLedgerAccount = defaultLedgerAccount
        self.cogsAccount = cogsAccount
        self.customFields = customFields
        self.extendedEntities = extendedEntities
        self.channels = channels
        self.packs = packs
        self.upcs = upcs
        self.productCategory = productCategory
        self.styleNumber = styleNumber
        self.styleName = styleName
        self.colorName = colorName
        self.colorCode = colorCode
        self.size = size
        self.nmfcNumber = nmfcNumber
        self.harmonizedCode = harmonizedCode
        self.mixLots = mixLots
        self.transportationClass = transportationClass
        self.customMappings = customMappings
        self.components = components
        self.itemVendors = itemVendors
        self.customAttribute1 = customAttribute1
        self.customAttribute2 = customAttribute2
        self.customAttribute3 = customAttribute3
        self.customAttribute4 = customAttribute4
        self.customAttribute5 = customAttribute5
        self.ule = ule
        self.uleUom = uleUom
        self.kitOrderOnly = kitOrderOnly
        self.kitStockOnly = kitStockOnly
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemType.subclass:
            return ItemType.subclass(*args_, **kwargs_)
        else:
            return ItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def get_facility(self): return self.facility
    def set_facility(self, facility): self.facility = facility
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_classType(self): return self.classType
    def set_classType(self, classType): self.classType = classType
    def get_shortDescription(self): return self.shortDescription
    def set_shortDescription(self, shortDescription): self.shortDescription = shortDescription
    def get_longDescription(self): return self.longDescription
    def set_longDescription(self, longDescription): self.longDescription = longDescription
    def get_dimension(self): return self.dimension
    def set_dimension(self, dimension): self.dimension = dimension
    def get_itemWeight(self): return self.itemWeight
    def set_itemWeight(self, itemWeight): self.itemWeight = itemWeight
    def get_abcCategory(self): return self.abcCategory
    def set_abcCategory(self, abcCategory): self.abcCategory = abcCategory
    def get_productCode(self): return self.productCode
    def set_productCode(self, productCode): self.productCode = productCode
    def get_originCountry(self): return self.originCountry
    def set_originCountry(self, originCountry): self.originCountry = originCountry
    def get_cycleCount(self): return self.cycleCount
    def set_cycleCount(self, cycleCount): self.cycleCount = cycleCount
    def get_tradingPartner(self): return self.tradingPartner
    def set_tradingPartner(self, tradingPartner): self.tradingPartner = tradingPartner
    def get_purchaseCost(self): return self.purchaseCost
    def set_purchaseCost(self, purchaseCost): self.purchaseCost = purchaseCost
    def get_unitPrice(self): return self.unitPrice
    def set_unitPrice(self, unitPrice): self.unitPrice = unitPrice
    def get_bornOnDateRequired(self): return self.bornOnDateRequired
    def set_bornOnDateRequired(self, bornOnDateRequired): self.bornOnDateRequired = bornOnDateRequired
    def get_expirationDateRequired(self): return self.expirationDateRequired
    def set_expirationDateRequired(self, expirationDateRequired): self.expirationDateRequired = expirationDateRequired
    def get_receiveDateRequired(self): return self.receiveDateRequired
    def set_receiveDateRequired(self, receiveDateRequired): self.receiveDateRequired = receiveDateRequired
    def get_quarantineRequired(self): return self.quarantineRequired
    def set_quarantineRequired(self, quarantineRequired): self.quarantineRequired = quarantineRequired
    def get_inspectionRequired(self): return self.inspectionRequired
    def set_inspectionRequired(self, inspectionRequired): self.inspectionRequired = inspectionRequired
    def get_catchWeightRequired(self): return self.catchWeightRequired
    def set_catchWeightRequired(self, catchWeightRequired): self.catchWeightRequired = catchWeightRequired
    def get_hazmat(self): return self.hazmat
    def set_hazmat(self, hazmat): self.hazmat = hazmat
    def get_hazmatCode(self): return self.hazmatCode
    def set_hazmatCode(self, hazmatCode): self.hazmatCode = hazmatCode
    def get_intangibleItemFlag(self): return self.intangibleItemFlag
    def set_intangibleItemFlag(self, intangibleItemFlag): self.intangibleItemFlag = intangibleItemFlag
    def get_inventoryTrackingEnabled(self): return self.inventoryTrackingEnabled
    def set_inventoryTrackingEnabled(self, inventoryTrackingEnabled): self.inventoryTrackingEnabled = inventoryTrackingEnabled
    def get_lotTrackingEnabled(self): return self.lotTrackingEnabled
    def set_lotTrackingEnabled(self, lotTrackingEnabled): self.lotTrackingEnabled = lotTrackingEnabled
    def get_serialTrackingEnabled(self): return self.serialTrackingEnabled
    def set_serialTrackingEnabled(self, serialTrackingEnabled): self.serialTrackingEnabled = serialTrackingEnabled
    def get_shippable(self): return self.shippable
    def set_shippable(self, shippable): self.shippable = shippable
    def get_purchased(self): return self.purchased
    def set_purchased(self, purchased): self.purchased = purchased
    def get_receiveOverTolerance(self): return self.receiveOverTolerance
    def set_receiveOverTolerance(self, receiveOverTolerance): self.receiveOverTolerance = receiveOverTolerance
    def get_receiveUnderTolerance(self): return self.receiveUnderTolerance
    def set_receiveUnderTolerance(self, receiveUnderTolerance): self.receiveUnderTolerance = receiveUnderTolerance
    def get_cycleCountFrequency(self): return self.cycleCountFrequency
    def set_cycleCountFrequency(self, cycleCountFrequency): self.cycleCountFrequency = cycleCountFrequency
    def get_reorderQuantity(self): return self.reorderQuantity
    def set_reorderQuantity(self, reorderQuantity): self.reorderQuantity = reorderQuantity
    def get_accountingType(self): return self.accountingType
    def set_accountingType(self, accountingType): self.accountingType = accountingType
    def get_defaultLedgerAccount(self): return self.defaultLedgerAccount
    def set_defaultLedgerAccount(self, defaultLedgerAccount): self.defaultLedgerAccount = defaultLedgerAccount
    def get_cogsAccount(self): return self.cogsAccount
    def set_cogsAccount(self, cogsAccount): self.cogsAccount = cogsAccount
    def get_customFields(self): return self.customFields
    def set_customFields(self, customFields): self.customFields = customFields
    def get_extendedEntities(self): return self.extendedEntities
    def set_extendedEntities(self, extendedEntities): self.extendedEntities = extendedEntities
    def get_channels(self): return self.channels
    def set_channels(self, channels): self.channels = channels
    def get_packs(self): return self.packs
    def set_packs(self, packs): self.packs = packs
    def get_upcs(self): return self.upcs
    def set_upcs(self, upcs): self.upcs = upcs
    def get_productCategory(self): return self.productCategory
    def set_productCategory(self, productCategory): self.productCategory = productCategory
    def get_styleNumber(self): return self.styleNumber
    def set_styleNumber(self, styleNumber): self.styleNumber = styleNumber
    def get_styleName(self): return self.styleName
    def set_styleName(self, styleName): self.styleName = styleName
    def get_colorName(self): return self.colorName
    def set_colorName(self, colorName): self.colorName = colorName
    def get_colorCode(self): return self.colorCode
    def set_colorCode(self, colorCode): self.colorCode = colorCode
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_nmfcNumber(self): return self.nmfcNumber
    def set_nmfcNumber(self, nmfcNumber): self.nmfcNumber = nmfcNumber
    def get_harmonizedCode(self): return self.harmonizedCode
    def set_harmonizedCode(self, harmonizedCode): self.harmonizedCode = harmonizedCode
    def get_mixLots(self): return self.mixLots
    def set_mixLots(self, mixLots): self.mixLots = mixLots
    def get_transportationClass(self): return self.transportationClass
    def set_transportationClass(self, transportationClass): self.transportationClass = transportationClass
    def get_customMappings(self): return self.customMappings
    def set_customMappings(self, customMappings): self.customMappings = customMappings
    def get_components(self): return self.components
    def set_components(self, components): self.components = components
    def get_itemVendors(self): return self.itemVendors
    def set_itemVendors(self, itemVendors): self.itemVendors = itemVendors
    def get_customAttribute1(self): return self.customAttribute1
    def set_customAttribute1(self, customAttribute1): self.customAttribute1 = customAttribute1
    def get_customAttribute2(self): return self.customAttribute2
    def set_customAttribute2(self, customAttribute2): self.customAttribute2 = customAttribute2
    def get_customAttribute3(self): return self.customAttribute3
    def set_customAttribute3(self, customAttribute3): self.customAttribute3 = customAttribute3
    def get_customAttribute4(self): return self.customAttribute4
    def set_customAttribute4(self, customAttribute4): self.customAttribute4 = customAttribute4
    def get_customAttribute5(self): return self.customAttribute5
    def set_customAttribute5(self, customAttribute5): self.customAttribute5 = customAttribute5
    def get_ule(self): return self.ule
    def set_ule(self, ule): self.ule = ule
    def get_uleUom(self): return self.uleUom
    def set_uleUom(self, uleUom): self.uleUom = uleUom
    def get_kitOrderOnly(self): return self.kitOrderOnly
    def set_kitOrderOnly(self, kitOrderOnly): self.kitOrderOnly = kitOrderOnly
    def get_kitStockOnly(self): return self.kitStockOnly
    def set_kitStockOnly(self, kitStockOnly): self.kitStockOnly = kitStockOnly
    def validate_abcCategoryType(self, value):
        # Validate type abcCategoryType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'B', 'C']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on abcCategoryType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.businessUnit is not None or
            self.facility is not None or
            self.number is not None or
            self.name is not None or
            self.classType is not None or
            self.shortDescription is not None or
            self.longDescription is not None or
            self.dimension is not None or
            self.itemWeight is not None or
            self.abcCategory is not None or
            self.productCode is not None or
            self.originCountry is not None or
            self.cycleCount is not None or
            self.tradingPartner is not None or
            self.purchaseCost is not None or
            self.unitPrice is not None or
            self.bornOnDateRequired is not None or
            self.expirationDateRequired is not None or
            self.receiveDateRequired is not None or
            self.quarantineRequired is not None or
            self.inspectionRequired is not None or
            self.catchWeightRequired is not None or
            self.hazmat is not None or
            self.hazmatCode is not None or
            self.intangibleItemFlag is not None or
            self.inventoryTrackingEnabled is not None or
            self.lotTrackingEnabled is not None or
            self.serialTrackingEnabled is not None or
            self.shippable is not None or
            self.purchased is not None or
            self.receiveOverTolerance is not None or
            self.receiveUnderTolerance is not None or
            self.cycleCountFrequency is not None or
            self.reorderQuantity is not None or
            self.accountingType is not None or
            self.defaultLedgerAccount is not None or
            self.cogsAccount is not None or
            self.customFields is not None or
            self.extendedEntities is not None or
            self.channels is not None or
            self.packs is not None or
            self.upcs is not None or
            self.productCategory is not None or
            self.styleNumber is not None or
            self.styleName is not None or
            self.colorName is not None or
            self.colorCode is not None or
            self.size is not None or
            self.nmfcNumber is not None or
            self.harmonizedCode is not None or
            self.mixLots is not None or
            self.transportationClass is not None or
            self.customMappings is not None or
            self.components is not None or
            self.itemVendors is not None or
            self.customAttribute1 is not None or
            self.customAttribute2 is not None or
            self.customAttribute3 is not None or
            self.customAttribute4 is not None or
            self.customAttribute5 is not None or
            self.ule is not None or
            self.uleUom is not None or
            self.kitOrderOnly is not None or
            self.kitStockOnly is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ItemType', namespacedef_=' xmlns:t="http://integration.deposco.com/types"  xmlns:pack="http://integration.deposco.com/pack"  xmlns:upc="http://integration.deposco.com/upc"  xmlns:itemVendor="http://integration.deposco.com/itemVendor" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ItemType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ItemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessUnit>%s</%sbusinessUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessUnit), input_name='businessUnit')), namespace_, eol_))
        if self.facility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfacility>%s</%sfacility>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.facility), input_name='facility')), namespace_, eol_))
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.classType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclassType>%s</%sclassType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.classType), input_name='classType')), namespace_, eol_))
        if self.shortDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortDescription>%s</%sshortDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.shortDescription), input_name='shortDescription')), namespace_, eol_))
        if self.longDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongDescription>%s</%slongDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.longDescription), input_name='longDescription')), namespace_, eol_))
        if self.dimension is not None:
            self.dimension.export(outfile, level, namespace_, name_='dimension', pretty_print=pretty_print)
        if self.itemWeight is not None:
            self.itemWeight.export(outfile, level, namespace_, name_='itemWeight', pretty_print=pretty_print)
        if self.abcCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sabcCategory>%s</%sabcCategory>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.abcCategory), input_name='abcCategory')), namespace_, eol_))
        if self.productCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductCode>%s</%sproductCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.productCode), input_name='productCode')), namespace_, eol_))
        if self.originCountry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginCountry>%s</%soriginCountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.originCountry), input_name='originCountry')), namespace_, eol_))
        if self.cycleCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scycleCount>%s</%scycleCount>%s' % (namespace_, self.gds_format_boolean(self.cycleCount, input_name='cycleCount'), namespace_, eol_))
        if self.tradingPartner is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stradingPartner>%s</%stradingPartner>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tradingPartner), input_name='tradingPartner')), namespace_, eol_))
        if self.purchaseCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spurchaseCost>%s</%spurchaseCost>%s' % (namespace_, self.gds_format_double(self.purchaseCost, input_name='purchaseCost'), namespace_, eol_))
        if self.unitPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunitPrice>%s</%sunitPrice>%s' % (namespace_, self.gds_format_double(self.unitPrice, input_name='unitPrice'), namespace_, eol_))
        if self.bornOnDateRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbornOnDateRequired>%s</%sbornOnDateRequired>%s' % (namespace_, self.gds_format_boolean(self.bornOnDateRequired, input_name='bornOnDateRequired'), namespace_, eol_))
        if self.expirationDateRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpirationDateRequired>%s</%sexpirationDateRequired>%s' % (namespace_, self.gds_format_boolean(self.expirationDateRequired, input_name='expirationDateRequired'), namespace_, eol_))
        if self.receiveDateRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreceiveDateRequired>%s</%sreceiveDateRequired>%s' % (namespace_, self.gds_format_boolean(self.receiveDateRequired, input_name='receiveDateRequired'), namespace_, eol_))
        if self.quarantineRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squarantineRequired>%s</%squarantineRequired>%s' % (namespace_, self.gds_format_boolean(self.quarantineRequired, input_name='quarantineRequired'), namespace_, eol_))
        if self.inspectionRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinspectionRequired>%s</%sinspectionRequired>%s' % (namespace_, self.gds_format_boolean(self.inspectionRequired, input_name='inspectionRequired'), namespace_, eol_))
        if self.catchWeightRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scatchWeightRequired>%s</%scatchWeightRequired>%s' % (namespace_, self.gds_format_boolean(self.catchWeightRequired, input_name='catchWeightRequired'), namespace_, eol_))
        if self.hazmat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shazmat>%s</%shazmat>%s' % (namespace_, self.gds_format_boolean(self.hazmat, input_name='hazmat'), namespace_, eol_))
        if self.hazmatCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shazmatCode>%s</%shazmatCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.hazmatCode), input_name='hazmatCode')), namespace_, eol_))
        if self.intangibleItemFlag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintangibleItemFlag>%s</%sintangibleItemFlag>%s' % (namespace_, self.gds_format_boolean(self.intangibleItemFlag, input_name='intangibleItemFlag'), namespace_, eol_))
        if self.inventoryTrackingEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinventoryTrackingEnabled>%s</%sinventoryTrackingEnabled>%s' % (namespace_, self.gds_format_boolean(self.inventoryTrackingEnabled, input_name='inventoryTrackingEnabled'), namespace_, eol_))
        if self.lotTrackingEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slotTrackingEnabled>%s</%slotTrackingEnabled>%s' % (namespace_, self.gds_format_boolean(self.lotTrackingEnabled, input_name='lotTrackingEnabled'), namespace_, eol_))
        if self.serialTrackingEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserialTrackingEnabled>%s</%sserialTrackingEnabled>%s' % (namespace_, self.gds_format_boolean(self.serialTrackingEnabled, input_name='serialTrackingEnabled'), namespace_, eol_))
        if self.shippable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshippable>%s</%sshippable>%s' % (namespace_, self.gds_format_boolean(self.shippable, input_name='shippable'), namespace_, eol_))
        if self.purchased is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spurchased>%s</%spurchased>%s' % (namespace_, self.gds_format_boolean(self.purchased, input_name='purchased'), namespace_, eol_))
        if self.receiveOverTolerance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreceiveOverTolerance>%s</%sreceiveOverTolerance>%s' % (namespace_, self.gds_format_double(self.receiveOverTolerance, input_name='receiveOverTolerance'), namespace_, eol_))
        if self.receiveUnderTolerance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreceiveUnderTolerance>%s</%sreceiveUnderTolerance>%s' % (namespace_, self.gds_format_double(self.receiveUnderTolerance, input_name='receiveUnderTolerance'), namespace_, eol_))
        if self.cycleCountFrequency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scycleCountFrequency>%s</%scycleCountFrequency>%s' % (namespace_, self.gds_format_integer(self.cycleCountFrequency, input_name='cycleCountFrequency'), namespace_, eol_))
        if self.reorderQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreorderQuantity>%s</%sreorderQuantity>%s' % (namespace_, self.gds_format_integer(self.reorderQuantity, input_name='reorderQuantity'), namespace_, eol_))
        if self.accountingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccountingType>%s</%saccountingType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.accountingType), input_name='accountingType')), namespace_, eol_))
        if self.defaultLedgerAccount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefaultLedgerAccount>%s</%sdefaultLedgerAccount>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.defaultLedgerAccount), input_name='defaultLedgerAccount')), namespace_, eol_))
        if self.cogsAccount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scogsAccount>%s</%scogsAccount>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cogsAccount), input_name='cogsAccount')), namespace_, eol_))
        if self.customFields is not None:
            self.customFields.export(outfile, level, namespace_, name_='customFields', pretty_print=pretty_print)
        if self.extendedEntities is not None:
            self.extendedEntities.export(outfile, level, namespace_, name_='extendedEntities', pretty_print=pretty_print)
        if self.channels is not None:
            self.channels.export(outfile, level, namespace_, name_='channels', pretty_print=pretty_print)
        if self.packs is not None:
            self.packs.export(outfile, level, namespace_, name_='packs', pretty_print=pretty_print)
        if self.upcs is not None:
            self.upcs.export(outfile, level, namespace_, name_='upcs', pretty_print=pretty_print)
        if self.productCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproductCategory>%s</%sproductCategory>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.productCategory), input_name='productCategory')), namespace_, eol_))
        if self.styleNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstyleNumber>%s</%sstyleNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.styleNumber), input_name='styleNumber')), namespace_, eol_))
        if self.styleName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstyleName>%s</%sstyleName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.styleName), input_name='styleName')), namespace_, eol_))
        if self.colorName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scolorName>%s</%scolorName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.colorName), input_name='colorName')), namespace_, eol_))
        if self.colorCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scolorCode>%s</%scolorCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.colorCode), input_name='colorCode')), namespace_, eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.size), input_name='size')), namespace_, eol_))
        if self.nmfcNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snmfcNumber>%s</%snmfcNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.nmfcNumber), input_name='nmfcNumber')), namespace_, eol_))
        if self.harmonizedCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sharmonizedCode>%s</%sharmonizedCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.harmonizedCode), input_name='harmonizedCode')), namespace_, eol_))
        if self.mixLots is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smixLots>%s</%smixLots>%s' % (namespace_, self.gds_format_boolean(self.mixLots, input_name='mixLots'), namespace_, eol_))
        if self.transportationClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransportationClass>%s</%stransportationClass>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.transportationClass), input_name='transportationClass')), namespace_, eol_))
        if self.customMappings is not None:
            self.customMappings.export(outfile, level, namespace_, name_='customMappings', pretty_print=pretty_print)
        if self.components is not None:
            self.components.export(outfile, level, namespace_, name_='components', pretty_print=pretty_print)
        if self.itemVendors is not None:
            self.itemVendors.export(outfile, level, namespace_, name_='itemVendors', pretty_print=pretty_print)
        if self.customAttribute1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomAttribute1>%s</%scustomAttribute1>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.customAttribute1), input_name='customAttribute1')), namespace_, eol_))
        if self.customAttribute2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomAttribute2>%s</%scustomAttribute2>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.customAttribute2), input_name='customAttribute2')), namespace_, eol_))
        if self.customAttribute3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomAttribute3>%s</%scustomAttribute3>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.customAttribute3), input_name='customAttribute3')), namespace_, eol_))
        if self.customAttribute4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomAttribute4>%s</%scustomAttribute4>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.customAttribute4), input_name='customAttribute4')), namespace_, eol_))
        if self.customAttribute5 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomAttribute5>%s</%scustomAttribute5>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.customAttribute5), input_name='customAttribute5')), namespace_, eol_))
        if self.ule is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sule>%s</%sule>%s' % (namespace_, self.gds_format_double(self.ule, input_name='ule'), namespace_, eol_))
        if self.uleUom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suleUom>%s</%suleUom>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.uleUom), input_name='uleUom')), namespace_, eol_))
        if self.kitOrderOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skitOrderOnly>%s</%skitOrderOnly>%s' % (namespace_, self.gds_format_boolean(self.kitOrderOnly, input_name='kitOrderOnly'), namespace_, eol_))
        if self.kitStockOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skitStockOnly>%s</%skitStockOnly>%s' % (namespace_, self.gds_format_boolean(self.kitStockOnly, input_name='kitStockOnly'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessUnit':
            businessUnit_ = child_.text
            businessUnit_ = self.gds_validate_string(businessUnit_, node, 'businessUnit')
            self.businessUnit = businessUnit_
        elif nodeName_ == 'facility':
            facility_ = child_.text
            facility_ = self.gds_validate_string(facility_, node, 'facility')
            self.facility = facility_
        elif nodeName_ == 'number':
            number_ = child_.text
            number_ = self.gds_validate_string(number_, node, 'number')
            self.number = number_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'classType':
            classType_ = child_.text
            classType_ = self.gds_validate_string(classType_, node, 'classType')
            self.classType = classType_
        elif nodeName_ == 'shortDescription':
            shortDescription_ = child_.text
            shortDescription_ = self.gds_validate_string(shortDescription_, node, 'shortDescription')
            self.shortDescription = shortDescription_
        elif nodeName_ == 'longDescription':
            longDescription_ = child_.text
            longDescription_ = self.gds_validate_string(longDescription_, node, 'longDescription')
            self.longDescription = longDescription_
        elif nodeName_ == 'dimension':
            obj_ = DimensionType.factory()
            obj_.build(child_)
            self.dimension = obj_
            obj_.original_tagname_ = 'dimension'
        elif nodeName_ == 'itemWeight':
            obj_ = WeightType.factory()
            obj_.build(child_)
            self.itemWeight = obj_
            obj_.original_tagname_ = 'itemWeight'
        elif nodeName_ == 'abcCategory':
            abcCategory_ = child_.text
            abcCategory_ = self.gds_validate_string(abcCategory_, node, 'abcCategory')
            self.abcCategory = abcCategory_
            # validate type abcCategoryType
            self.validate_abcCategoryType(self.abcCategory)
        elif nodeName_ == 'productCode':
            productCode_ = child_.text
            productCode_ = self.gds_validate_string(productCode_, node, 'productCode')
            self.productCode = productCode_
        elif nodeName_ == 'originCountry':
            originCountry_ = child_.text
            originCountry_ = self.gds_validate_string(originCountry_, node, 'originCountry')
            self.originCountry = originCountry_
        elif nodeName_ == 'cycleCount':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'cycleCount')
            self.cycleCount = ival_
        elif nodeName_ == 'tradingPartner':
            tradingPartner_ = child_.text
            tradingPartner_ = self.gds_validate_string(tradingPartner_, node, 'tradingPartner')
            self.tradingPartner = tradingPartner_
        elif nodeName_ == 'purchaseCost':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'purchaseCost')
            self.purchaseCost = fval_
        elif nodeName_ == 'unitPrice':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'unitPrice')
            self.unitPrice = fval_
        elif nodeName_ == 'bornOnDateRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'bornOnDateRequired')
            self.bornOnDateRequired = ival_
        elif nodeName_ == 'expirationDateRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'expirationDateRequired')
            self.expirationDateRequired = ival_
        elif nodeName_ == 'receiveDateRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'receiveDateRequired')
            self.receiveDateRequired = ival_
        elif nodeName_ == 'quarantineRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'quarantineRequired')
            self.quarantineRequired = ival_
        elif nodeName_ == 'inspectionRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'inspectionRequired')
            self.inspectionRequired = ival_
        elif nodeName_ == 'catchWeightRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'catchWeightRequired')
            self.catchWeightRequired = ival_
        elif nodeName_ == 'hazmat':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'hazmat')
            self.hazmat = ival_
        elif nodeName_ == 'hazmatCode':
            hazmatCode_ = child_.text
            hazmatCode_ = self.gds_validate_string(hazmatCode_, node, 'hazmatCode')
            self.hazmatCode = hazmatCode_
        elif nodeName_ == 'intangibleItemFlag':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'intangibleItemFlag')
            self.intangibleItemFlag = ival_
        elif nodeName_ == 'inventoryTrackingEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'inventoryTrackingEnabled')
            self.inventoryTrackingEnabled = ival_
        elif nodeName_ == 'lotTrackingEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'lotTrackingEnabled')
            self.lotTrackingEnabled = ival_
        elif nodeName_ == 'serialTrackingEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'serialTrackingEnabled')
            self.serialTrackingEnabled = ival_
        elif nodeName_ == 'shippable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'shippable')
            self.shippable = ival_
        elif nodeName_ == 'purchased':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'purchased')
            self.purchased = ival_
        elif nodeName_ == 'receiveOverTolerance':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'receiveOverTolerance')
            self.receiveOverTolerance = fval_
        elif nodeName_ == 'receiveUnderTolerance':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'receiveUnderTolerance')
            self.receiveUnderTolerance = fval_
        elif nodeName_ == 'cycleCountFrequency':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cycleCountFrequency')
            self.cycleCountFrequency = ival_
        elif nodeName_ == 'reorderQuantity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reorderQuantity')
            self.reorderQuantity = ival_
        elif nodeName_ == 'accountingType':
            accountingType_ = child_.text
            accountingType_ = self.gds_validate_string(accountingType_, node, 'accountingType')
            self.accountingType = accountingType_
        elif nodeName_ == 'defaultLedgerAccount':
            defaultLedgerAccount_ = child_.text
            defaultLedgerAccount_ = self.gds_validate_string(defaultLedgerAccount_, node, 'defaultLedgerAccount')
            self.defaultLedgerAccount = defaultLedgerAccount_
        elif nodeName_ == 'cogsAccount':
            cogsAccount_ = child_.text
            cogsAccount_ = self.gds_validate_string(cogsAccount_, node, 'cogsAccount')
            self.cogsAccount = cogsAccount_
        elif nodeName_ == 'customFields':
            obj_ = CustomFieldCollection.factory()
            obj_.build(child_)
            self.customFields = obj_
            obj_.original_tagname_ = 'customFields'
        elif nodeName_ == 'extendedEntities':
            obj_ = ExtendedEntityCollection.factory()
            obj_.build(child_)
            self.extendedEntities = obj_
            obj_.original_tagname_ = 'extendedEntities'
        elif nodeName_ == 'channels':
            obj_ = ChannelsCollection.factory()
            obj_.build(child_)
            self.channels = obj_
            obj_.original_tagname_ = 'channels'
        elif nodeName_ == 'packs':
            obj_ = PackCollection.factory()
            obj_.build(child_)
            self.packs = obj_
            obj_.original_tagname_ = 'packs'
        elif nodeName_ == 'upcs':
            obj_ = UPCCollection.factory()
            obj_.build(child_)
            self.upcs = obj_
            obj_.original_tagname_ = 'upcs'
        elif nodeName_ == 'productCategory':
            productCategory_ = child_.text
            productCategory_ = self.gds_validate_string(productCategory_, node, 'productCategory')
            self.productCategory = productCategory_
        elif nodeName_ == 'styleNumber':
            styleNumber_ = child_.text
            styleNumber_ = self.gds_validate_string(styleNumber_, node, 'styleNumber')
            self.styleNumber = styleNumber_
        elif nodeName_ == 'styleName':
            styleName_ = child_.text
            styleName_ = self.gds_validate_string(styleName_, node, 'styleName')
            self.styleName = styleName_
        elif nodeName_ == 'colorName':
            colorName_ = child_.text
            colorName_ = self.gds_validate_string(colorName_, node, 'colorName')
            self.colorName = colorName_
        elif nodeName_ == 'colorCode':
            colorCode_ = child_.text
            colorCode_ = self.gds_validate_string(colorCode_, node, 'colorCode')
            self.colorCode = colorCode_
        elif nodeName_ == 'size':
            size_ = child_.text
            size_ = self.gds_validate_string(size_, node, 'size')
            self.size = size_
        elif nodeName_ == 'nmfcNumber':
            nmfcNumber_ = child_.text
            nmfcNumber_ = self.gds_validate_string(nmfcNumber_, node, 'nmfcNumber')
            self.nmfcNumber = nmfcNumber_
        elif nodeName_ == 'harmonizedCode':
            harmonizedCode_ = child_.text
            harmonizedCode_ = self.gds_validate_string(harmonizedCode_, node, 'harmonizedCode')
            self.harmonizedCode = harmonizedCode_
        elif nodeName_ == 'mixLots':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'mixLots')
            self.mixLots = ival_
        elif nodeName_ == 'transportationClass':
            transportationClass_ = child_.text
            transportationClass_ = self.gds_validate_string(transportationClass_, node, 'transportationClass')
            self.transportationClass = transportationClass_
        elif nodeName_ == 'customMappings':
            obj_ = CustomMapCollection.factory()
            obj_.build(child_)
            self.customMappings = obj_
            obj_.original_tagname_ = 'customMappings'
        elif nodeName_ == 'components':
            obj_ = KitCollection.factory()
            obj_.build(child_)
            self.components = obj_
            obj_.original_tagname_ = 'components'
        elif nodeName_ == 'itemVendors':
            obj_ = ItemVendorCollection.factory()
            obj_.build(child_)
            self.itemVendors = obj_
            obj_.original_tagname_ = 'itemVendors'
        elif nodeName_ == 'customAttribute1':
            customAttribute1_ = child_.text
            customAttribute1_ = self.gds_validate_string(customAttribute1_, node, 'customAttribute1')
            self.customAttribute1 = customAttribute1_
        elif nodeName_ == 'customAttribute2':
            customAttribute2_ = child_.text
            customAttribute2_ = self.gds_validate_string(customAttribute2_, node, 'customAttribute2')
            self.customAttribute2 = customAttribute2_
        elif nodeName_ == 'customAttribute3':
            customAttribute3_ = child_.text
            customAttribute3_ = self.gds_validate_string(customAttribute3_, node, 'customAttribute3')
            self.customAttribute3 = customAttribute3_
        elif nodeName_ == 'customAttribute4':
            customAttribute4_ = child_.text
            customAttribute4_ = self.gds_validate_string(customAttribute4_, node, 'customAttribute4')
            self.customAttribute4 = customAttribute4_
        elif nodeName_ == 'customAttribute5':
            customAttribute5_ = child_.text
            customAttribute5_ = self.gds_validate_string(customAttribute5_, node, 'customAttribute5')
            self.customAttribute5 = customAttribute5_
        elif nodeName_ == 'ule':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ule')
            self.ule = fval_
        elif nodeName_ == 'uleUom':
            uleUom_ = child_.text
            uleUom_ = self.gds_validate_string(uleUom_, node, 'uleUom')
            self.uleUom = uleUom_
        elif nodeName_ == 'kitOrderOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'kitOrderOnly')
            self.kitOrderOnly = ival_
        elif nodeName_ == 'kitStockOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'kitStockOnly')
            self.kitStockOnly = ival_
# end class ItemType


class KitCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, component=None):
        self.original_tagname_ = None
        if component is None:
            self.component = []
        else:
            self.component = component
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KitCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KitCollection.subclass:
            return KitCollection.subclass(*args_, **kwargs_)
        else:
            return KitCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_component(self): return self.component
    def set_component(self, component): self.component = component
    def add_component(self, value): self.component.append(value)
    def insert_component_at(self, index, value): self.component.insert(index, value)
    def replace_component_at(self, index, value): self.component[index] = value
    def hasContent_(self):
        if (
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KitCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KitCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KitCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KitCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KitCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KitCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for component_ in self.component:
            component_.export(outfile, level, namespace_, name_='component', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'component':
            obj_ = KitComponentType.factory()
            obj_.build(child_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class KitCollection


class KitComponentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, componentItem=None, quantity=None):
        self.original_tagname_ = None
        self.componentItem = componentItem
        self.quantity = quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KitComponentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KitComponentType.subclass:
            return KitComponentType.subclass(*args_, **kwargs_)
        else:
            return KitComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentItem(self): return self.componentItem
    def set_componentItem(self, componentItem): self.componentItem = componentItem
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def hasContent_(self):
        if (
            self.componentItem is not None or
            self.quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KitComponentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KitComponentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KitComponentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KitComponentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KitComponentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KitComponentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.componentItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomponentItem>%s</%scomponentItem>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.componentItem), input_name='componentItem')), namespace_, eol_))
        if self.quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantity>%s</%squantity>%s' % (namespace_, self.gds_format_integer(self.quantity, input_name='quantity'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentItem':
            componentItem_ = child_.text
            componentItem_ = self.gds_validate_string(componentItem_, node, 'componentItem')
            self.componentItem = componentItem_
        elif nodeName_ == 'quantity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'quantity')
            self.quantity = ival_
# end class KitComponentType


class PackCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pack=None):
        self.original_tagname_ = None
        if pack is None:
            self.pack = []
        else:
            self.pack = pack
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackCollection.subclass:
            return PackCollection.subclass(*args_, **kwargs_)
        else:
            return PackCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pack(self): return self.pack
    def set_pack(self, pack): self.pack = pack
    def add_pack(self, value): self.pack.append(value)
    def insert_pack_at(self, index, value): self.pack.insert(index, value)
    def replace_pack_at(self, index, value): self.pack[index] = value
    def hasContent_(self):
        if (
            self.pack
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PackCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PackCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PackCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PackCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pack_ in self.pack:
            pack_.export(outfile, level, namespace_, name_='pack', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pack':
            obj_ = PackType.factory()
            obj_.build(child_)
            self.pack.append(obj_)
            obj_.original_tagname_ = 'pack'
# end class PackCollection


class PackType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, quantity=None, weight=None, boxTypes=None, dimension=None, upcs=None, customMappings=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.quantity = quantity
        self.weight = weight
        self.boxTypes = boxTypes
        self.dimension = dimension
        self.upcs = upcs
        self.customMappings = customMappings
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackType.subclass:
            return PackType.subclass(*args_, **kwargs_)
        else:
            return PackType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def get_boxTypes(self): return self.boxTypes
    def set_boxTypes(self, boxTypes): self.boxTypes = boxTypes
    def get_dimension(self): return self.dimension
    def set_dimension(self, dimension): self.dimension = dimension
    def get_upcs(self): return self.upcs
    def set_upcs(self, upcs): self.upcs = upcs
    def get_customMappings(self): return self.customMappings
    def set_customMappings(self, customMappings): self.customMappings = customMappings
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.quantity is not None or
            self.weight is not None or
            self.boxTypes is not None or
            self.dimension is not None or
            self.upcs is not None or
            self.customMappings is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PackType', namespacedef_=' xmlns:t="http://integration.deposco.com/types"  xmlns:upc="http://integration.deposco.com/upc" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PackType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PackType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PackType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
        if self.quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantity>%s</%squantity>%s' % (namespace_, self.gds_format_integer(self.quantity, input_name='quantity'), namespace_, eol_))
        if self.weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweight>%s</%sweight>%s' % (namespace_, self.gds_format_double(self.weight, input_name='weight'), namespace_, eol_))
        if self.boxTypes is not None:
            self.boxTypes.export(outfile, level, namespace_, name_='boxTypes', pretty_print=pretty_print)
        if self.dimension is not None:
            self.dimension.export(outfile, level, namespace_, name_='dimension', pretty_print=pretty_print)
        if self.upcs is not None:
            self.upcs.export(outfile, level, namespace_, name_='upcs', pretty_print=pretty_print)
        if self.customMappings is not None:
            self.customMappings.export(outfile, level, namespace_, name_='customMappings', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'quantity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'quantity')
            self.quantity = ival_
        elif nodeName_ == 'weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'weight')
            self.weight = fval_
        elif nodeName_ == 'boxTypes':
            obj_ = BoxTypeCollection.factory()
            obj_.build(child_)
            self.boxTypes = obj_
            obj_.original_tagname_ = 'boxTypes'
        elif nodeName_ == 'dimension':
            obj_ = DimensionType.factory()
            obj_.build(child_)
            self.dimension = obj_
            obj_.original_tagname_ = 'dimension'
        elif nodeName_ == 'upcs':
            obj_ = UPCCollection.factory()
            obj_.build(child_)
            self.upcs = obj_
            obj_.original_tagname_ = 'upcs'
        elif nodeName_ == 'customMappings':
            obj_ = CustomMapCollection.factory()
            obj_.build(child_)
            self.customMappings = obj_
            obj_.original_tagname_ = 'customMappings'
# end class PackType


class BoxTypeCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, boxType=None):
        self.original_tagname_ = None
        if boxType is None:
            self.boxType = []
        else:
            self.boxType = boxType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoxTypeCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoxTypeCollection.subclass:
            return BoxTypeCollection.subclass(*args_, **kwargs_)
        else:
            return BoxTypeCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boxType(self): return self.boxType
    def set_boxType(self, boxType): self.boxType = boxType
    def add_boxType(self, value): self.boxType.append(value)
    def insert_boxType_at(self, index, value): self.boxType.insert(index, value)
    def replace_boxType_at(self, index, value): self.boxType[index] = value
    def hasContent_(self):
        if (
            self.boxType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BoxTypeCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BoxTypeCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoxTypeCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BoxTypeCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoxTypeCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BoxTypeCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for boxType_ in self.boxType:
            boxType_.export(outfile, level, namespace_, name_='boxType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boxType':
            obj_ = BoxTypeType.factory()
            obj_.build(child_)
            self.boxType.append(obj_)
            obj_.original_tagname_ = 'boxType'
# end class BoxTypeCollection


class BoxTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, itemNumber=None, quantity=None):
        self.original_tagname_ = None
        self.itemNumber = itemNumber
        self.quantity = quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoxTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoxTypeType.subclass:
            return BoxTypeType.subclass(*args_, **kwargs_)
        else:
            return BoxTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_itemNumber(self): return self.itemNumber
    def set_itemNumber(self, itemNumber): self.itemNumber = itemNumber
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def hasContent_(self):
        if (
            self.itemNumber is not None or
            self.quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BoxTypeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BoxTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoxTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BoxTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoxTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BoxTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.itemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sitemNumber>%s</%sitemNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.itemNumber), input_name='itemNumber')), namespace_, eol_))
        if self.quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantity>%s</%squantity>%s' % (namespace_, self.gds_format_integer(self.quantity, input_name='quantity'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'itemNumber':
            itemNumber_ = child_.text
            itemNumber_ = self.gds_validate_string(itemNumber_, node, 'itemNumber')
            self.itemNumber = itemNumber_
        elif nodeName_ == 'quantity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'quantity')
            self.quantity = ival_
# end class BoxTypeType


class CustomMapType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomMapType.subclass:
            return CustomMapType.subclass(*args_, **kwargs_)
        else:
            return CustomMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomMapType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class CustomMapType


class CustomMapCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, customMapping=None):
        self.original_tagname_ = None
        if customMapping is None:
            self.customMapping = []
        else:
            self.customMapping = customMapping
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomMapCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomMapCollection.subclass:
            return CustomMapCollection.subclass(*args_, **kwargs_)
        else:
            return CustomMapCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_customMapping(self): return self.customMapping
    def set_customMapping(self, customMapping): self.customMapping = customMapping
    def add_customMapping(self, value): self.customMapping.append(value)
    def insert_customMapping_at(self, index, value): self.customMapping.insert(index, value)
    def replace_customMapping_at(self, index, value): self.customMapping[index] = value
    def hasContent_(self):
        if (
            self.customMapping
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomMapCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomMapCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomMapCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomMapCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomMapCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomMapCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for customMapping_ in self.customMapping:
            customMapping_.export(outfile, level, namespace_, name_='customMapping', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'customMapping':
            obj_ = CustomMapType.factory()
            obj_.build(child_)
            self.customMapping.append(obj_)
            obj_.original_tagname_ = 'customMapping'
# end class CustomMapCollection


class DimensionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, length=None, width=None, height=None, volume=None, units='Inch'):
        self.original_tagname_ = None
        self.length = length
        self.width = width
        self.height = height
        self.volume = volume
        self.units = units
        self.validate_LengthUnitsType(self.units)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionType.subclass:
            return DimensionType.subclass(*args_, **kwargs_)
        else:
            return DimensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def get_volume(self): return self.volume
    def set_volume(self, volume): self.volume = volume
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_LengthUnitsType(self, value):
        # Validate type LengthUnitsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Inch']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LengthUnitsType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.length is not None or
            self.width is not None or
            self.height is not None or
            self.volume is not None or
            self.units != "Inch"
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DimensionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DimensionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DimensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DimensionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DimensionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DimensionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespace_, self.gds_format_double(self.length, input_name='length'), namespace_, eol_))
        if self.width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swidth>%s</%swidth>%s' % (namespace_, self.gds_format_double(self.width, input_name='width'), namespace_, eol_))
        if self.height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheight>%s</%sheight>%s' % (namespace_, self.gds_format_double(self.height, input_name='height'), namespace_, eol_))
        if self.volume is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume>%s</%svolume>%s' % (namespace_, self.gds_format_double(self.volume, input_name='volume'), namespace_, eol_))
        if self.units != "Inch":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunits>%s</%sunits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.units), input_name='units')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'length':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'length')
            self.length = fval_
        elif nodeName_ == 'width':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'width')
            self.width = fval_
        elif nodeName_ == 'height':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'height')
            self.height = fval_
        elif nodeName_ == 'volume':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'volume')
            self.volume = fval_
        elif nodeName_ == 'units':
            units_ = child_.text
            units_ = self.gds_validate_string(units_, node, 'units')
            self.units = units_
            # validate type LengthUnitsType
            self.validate_LengthUnitsType(self.units)
# end class DimensionType


class WeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, weight=None, units='Pound'):
        self.original_tagname_ = None
        self.weight = weight
        self.units = units
        self.validate_WeightUnitsType(self.units)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightType.subclass:
            return WeightType.subclass(*args_, **kwargs_)
        else:
            return WeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_WeightUnitsType(self, value):
        # Validate type WeightUnitsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Pound']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeightUnitsType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.weight is not None or
            self.units != "Pound"
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweight>%s</%sweight>%s' % (namespace_, self.gds_format_double(self.weight, input_name='weight'), namespace_, eol_))
        if self.units != "Pound":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunits>%s</%sunits>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.units), input_name='units')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'weight')
            self.weight = fval_
        elif nodeName_ == 'units':
            units_ = child_.text
            units_ = self.gds_validate_string(units_, node, 'units')
            self.units = units_
            # validate type WeightUnitsType
            self.validate_WeightUnitsType(self.units)
# end class WeightType


class CustomFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, type_='String'):
        self.original_tagname_ = None
        self.name = name
        self.value = value
        self.type_ = type_
        self.validate_typeType(self.type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomFieldType.subclass:
            return CustomFieldType.subclass(*args_, **kwargs_)
        else:
            return CustomFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Integer', 'String', 'Double', 'Boolean']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None or
            self.type_ != "String"
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomFieldType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomFieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomFieldType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomFieldType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomFieldType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomFieldType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespace_, eol_))
        if self.type_ != "String":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type typeType
            self.validate_typeType(self.type_)
# end class CustomFieldType


class CustomFieldCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, customField=None):
        self.original_tagname_ = None
        if customField is None:
            self.customField = []
        else:
            self.customField = customField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomFieldCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomFieldCollection.subclass:
            return CustomFieldCollection.subclass(*args_, **kwargs_)
        else:
            return CustomFieldCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_customField(self): return self.customField
    def set_customField(self, customField): self.customField = customField
    def add_customField(self, value): self.customField.append(value)
    def insert_customField_at(self, index, value): self.customField.insert(index, value)
    def replace_customField_at(self, index, value): self.customField[index] = value
    def hasContent_(self):
        if (
            self.customField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomFieldCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomFieldCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomFieldCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomFieldCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomFieldCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomFieldCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for customField_ in self.customField:
            customField_.export(outfile, level, namespace_, name_='customField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'customField':
            obj_ = CustomFieldType.factory()
            obj_.build(child_)
            self.customField.append(obj_)
            obj_.original_tagname_ = 'customField'
# end class CustomFieldCollection


class ChannelsCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, channel=None):
        self.original_tagname_ = None
        if channel is None:
            self.channel = []
        else:
            self.channel = channel
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelsCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelsCollection.subclass:
            return ChannelsCollection.subclass(*args_, **kwargs_)
        else:
            return ChannelsCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    def add_channel(self, value): self.channel.append(value)
    def insert_channel_at(self, index, value): self.channel.insert(index, value)
    def replace_channel_at(self, index, value): self.channel[index] = value
    def hasContent_(self):
        if (
            self.channel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChannelsCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelsCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelsCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChannelsCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelsCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelsCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for channel_ in self.channel:
            channel_.export(outfile, level, namespace_, name_='channel', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'channel':
            obj_ = ChannelFieldType.factory()
            obj_.build(child_)
            self.channel.append(obj_)
            obj_.original_tagname_ = 'channel'
# end class ChannelsCollection


class ChannelsResourceCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, channel=None):
        self.original_tagname_ = None
        if channel is None:
            self.channel = []
        else:
            self.channel = channel
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelsResourceCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelsResourceCollection.subclass:
            return ChannelsResourceCollection.subclass(*args_, **kwargs_)
        else:
            return ChannelsResourceCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    def add_channel(self, value): self.channel.append(value)
    def insert_channel_at(self, index, value): self.channel.insert(index, value)
    def replace_channel_at(self, index, value): self.channel[index] = value
    def hasContent_(self):
        if (
            self.channel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChannelsResourceCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelsResourceCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelsResourceCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChannelsResourceCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelsResourceCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelsResourceCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for channel_ in self.channel:
            channel_.export(outfile, level, namespace_, name_='channel', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'channel':
            obj_ = ChannelResourceFieldType.factory()
            obj_.build(child_)
            self.channel.append(obj_)
            obj_.original_tagname_ = 'channel'
# end class ChannelsResourceCollection


class ChannelResourceFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, businessUnit=None, businessKey=None, otherKey=None, entityType=None, feedName=None, jobName=None, ref1=None, ref2=None, ref3=None, ref4=None, ref5=None, secRef1=None, secRef2=None, secRef3=None, secRef4=None, secRef5=None, valueOf_=None):
        self.original_tagname_ = None
        self.businessUnit = _cast(None, businessUnit)
        self.businessKey = _cast(None, businessKey)
        self.otherKey = _cast(None, otherKey)
        self.entityType = _cast(None, entityType)
        self.feedName = _cast(None, feedName)
        self.jobName = _cast(None, jobName)
        self.ref1 = _cast(None, ref1)
        self.ref2 = _cast(None, ref2)
        self.ref3 = _cast(None, ref3)
        self.ref4 = _cast(None, ref4)
        self.ref5 = _cast(None, ref5)
        self.secRef1 = _cast(None, secRef1)
        self.secRef2 = _cast(None, secRef2)
        self.secRef3 = _cast(None, secRef3)
        self.secRef4 = _cast(None, secRef4)
        self.secRef5 = _cast(None, secRef5)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelResourceFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelResourceFieldType.subclass:
            return ChannelResourceFieldType.subclass(*args_, **kwargs_)
        else:
            return ChannelResourceFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def get_businessKey(self): return self.businessKey
    def set_businessKey(self, businessKey): self.businessKey = businessKey
    def get_otherKey(self): return self.otherKey
    def set_otherKey(self, otherKey): self.otherKey = otherKey
    def get_entityType(self): return self.entityType
    def set_entityType(self, entityType): self.entityType = entityType
    def get_feedName(self): return self.feedName
    def set_feedName(self, feedName): self.feedName = feedName
    def get_jobName(self): return self.jobName
    def set_jobName(self, jobName): self.jobName = jobName
    def get_ref1(self): return self.ref1
    def set_ref1(self, ref1): self.ref1 = ref1
    def get_ref2(self): return self.ref2
    def set_ref2(self, ref2): self.ref2 = ref2
    def get_ref3(self): return self.ref3
    def set_ref3(self, ref3): self.ref3 = ref3
    def get_ref4(self): return self.ref4
    def set_ref4(self, ref4): self.ref4 = ref4
    def get_ref5(self): return self.ref5
    def set_ref5(self, ref5): self.ref5 = ref5
    def get_secRef1(self): return self.secRef1
    def set_secRef1(self, secRef1): self.secRef1 = secRef1
    def get_secRef2(self): return self.secRef2
    def set_secRef2(self, secRef2): self.secRef2 = secRef2
    def get_secRef3(self): return self.secRef3
    def set_secRef3(self, secRef3): self.secRef3 = secRef3
    def get_secRef4(self): return self.secRef4
    def set_secRef4(self, secRef4): self.secRef4 = secRef4
    def get_secRef5(self): return self.secRef5
    def set_secRef5(self, secRef5): self.secRef5 = secRef5
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChannelResourceFieldType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelResourceFieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelResourceFieldType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChannelResourceFieldType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelResourceFieldType'):
        if self.businessUnit is not None and 'businessUnit' not in already_processed:
            already_processed.add('businessUnit')
            outfile.write(' businessUnit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.businessUnit), input_name='businessUnit')), ))
        if self.businessKey is not None and 'businessKey' not in already_processed:
            already_processed.add('businessKey')
            outfile.write(' businessKey=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.businessKey), input_name='businessKey')), ))
        if self.otherKey is not None and 'otherKey' not in already_processed:
            already_processed.add('otherKey')
            outfile.write(' otherKey=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.otherKey), input_name='otherKey')), ))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            outfile.write(' entityType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.entityType), input_name='entityType')), ))
        if self.feedName is not None and 'feedName' not in already_processed:
            already_processed.add('feedName')
            outfile.write(' feedName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.feedName), input_name='feedName')), ))
        if self.jobName is not None and 'jobName' not in already_processed:
            already_processed.add('jobName')
            outfile.write(' jobName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.jobName), input_name='jobName')), ))
        if self.ref1 is not None and 'ref1' not in already_processed:
            already_processed.add('ref1')
            outfile.write(' ref1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref1), input_name='ref1')), ))
        if self.ref2 is not None and 'ref2' not in already_processed:
            already_processed.add('ref2')
            outfile.write(' ref2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref2), input_name='ref2')), ))
        if self.ref3 is not None and 'ref3' not in already_processed:
            already_processed.add('ref3')
            outfile.write(' ref3=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref3), input_name='ref3')), ))
        if self.ref4 is not None and 'ref4' not in already_processed:
            already_processed.add('ref4')
            outfile.write(' ref4=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref4), input_name='ref4')), ))
        if self.ref5 is not None and 'ref5' not in already_processed:
            already_processed.add('ref5')
            outfile.write(' ref5=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref5), input_name='ref5')), ))
        if self.secRef1 is not None and 'secRef1' not in already_processed:
            already_processed.add('secRef1')
            outfile.write(' secRef1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef1), input_name='secRef1')), ))
        if self.secRef2 is not None and 'secRef2' not in already_processed:
            already_processed.add('secRef2')
            outfile.write(' secRef2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef2), input_name='secRef2')), ))
        if self.secRef3 is not None and 'secRef3' not in already_processed:
            already_processed.add('secRef3')
            outfile.write(' secRef3=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef3), input_name='secRef3')), ))
        if self.secRef4 is not None and 'secRef4' not in already_processed:
            already_processed.add('secRef4')
            outfile.write(' secRef4=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef4), input_name='secRef4')), ))
        if self.secRef5 is not None and 'secRef5' not in already_processed:
            already_processed.add('secRef5')
            outfile.write(' secRef5=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef5), input_name='secRef5')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelResourceFieldType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('businessUnit', node)
        if value is not None and 'businessUnit' not in already_processed:
            already_processed.add('businessUnit')
            self.businessUnit = value
        value = find_attr_value_('businessKey', node)
        if value is not None and 'businessKey' not in already_processed:
            already_processed.add('businessKey')
            self.businessKey = value
        value = find_attr_value_('otherKey', node)
        if value is not None and 'otherKey' not in already_processed:
            already_processed.add('otherKey')
            self.otherKey = value
        value = find_attr_value_('entityType', node)
        if value is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            self.entityType = value
        value = find_attr_value_('feedName', node)
        if value is not None and 'feedName' not in already_processed:
            already_processed.add('feedName')
            self.feedName = value
        value = find_attr_value_('jobName', node)
        if value is not None and 'jobName' not in already_processed:
            already_processed.add('jobName')
            self.jobName = value
        value = find_attr_value_('ref1', node)
        if value is not None and 'ref1' not in already_processed:
            already_processed.add('ref1')
            self.ref1 = value
        value = find_attr_value_('ref2', node)
        if value is not None and 'ref2' not in already_processed:
            already_processed.add('ref2')
            self.ref2 = value
        value = find_attr_value_('ref3', node)
        if value is not None and 'ref3' not in already_processed:
            already_processed.add('ref3')
            self.ref3 = value
        value = find_attr_value_('ref4', node)
        if value is not None and 'ref4' not in already_processed:
            already_processed.add('ref4')
            self.ref4 = value
        value = find_attr_value_('ref5', node)
        if value is not None and 'ref5' not in already_processed:
            already_processed.add('ref5')
            self.ref5 = value
        value = find_attr_value_('secRef1', node)
        if value is not None and 'secRef1' not in already_processed:
            already_processed.add('secRef1')
            self.secRef1 = value
        value = find_attr_value_('secRef2', node)
        if value is not None and 'secRef2' not in already_processed:
            already_processed.add('secRef2')
            self.secRef2 = value
        value = find_attr_value_('secRef3', node)
        if value is not None and 'secRef3' not in already_processed:
            already_processed.add('secRef3')
            self.secRef3 = value
        value = find_attr_value_('secRef4', node)
        if value is not None and 'secRef4' not in already_processed:
            already_processed.add('secRef4')
            self.secRef4 = value
        value = find_attr_value_('secRef5', node)
        if value is not None and 'secRef5' not in already_processed:
            already_processed.add('secRef5')
            self.secRef5 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ChannelResourceFieldType


class ChannelFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, feedName=None, jobName=None, ref1=None, ref2=None, ref3=None, ref4=None, ref5=None, secRef1=None, secRef2=None, secRef3=None, secRef4=None, secRef5=None, valueOf_=None):
        self.original_tagname_ = None
        self.feedName = _cast(None, feedName)
        self.jobName = _cast(None, jobName)
        self.ref1 = _cast(None, ref1)
        self.ref2 = _cast(None, ref2)
        self.ref3 = _cast(None, ref3)
        self.ref4 = _cast(None, ref4)
        self.ref5 = _cast(None, ref5)
        self.secRef1 = _cast(None, secRef1)
        self.secRef2 = _cast(None, secRef2)
        self.secRef3 = _cast(None, secRef3)
        self.secRef4 = _cast(None, secRef4)
        self.secRef5 = _cast(None, secRef5)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChannelFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChannelFieldType.subclass:
            return ChannelFieldType.subclass(*args_, **kwargs_)
        else:
            return ChannelFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_feedName(self): return self.feedName
    def set_feedName(self, feedName): self.feedName = feedName
    def get_jobName(self): return self.jobName
    def set_jobName(self, jobName): self.jobName = jobName
    def get_ref1(self): return self.ref1
    def set_ref1(self, ref1): self.ref1 = ref1
    def get_ref2(self): return self.ref2
    def set_ref2(self, ref2): self.ref2 = ref2
    def get_ref3(self): return self.ref3
    def set_ref3(self, ref3): self.ref3 = ref3
    def get_ref4(self): return self.ref4
    def set_ref4(self, ref4): self.ref4 = ref4
    def get_ref5(self): return self.ref5
    def set_ref5(self, ref5): self.ref5 = ref5
    def get_secRef1(self): return self.secRef1
    def set_secRef1(self, secRef1): self.secRef1 = secRef1
    def get_secRef2(self): return self.secRef2
    def set_secRef2(self, secRef2): self.secRef2 = secRef2
    def get_secRef3(self): return self.secRef3
    def set_secRef3(self, secRef3): self.secRef3 = secRef3
    def get_secRef4(self): return self.secRef4
    def set_secRef4(self, secRef4): self.secRef4 = secRef4
    def get_secRef5(self): return self.secRef5
    def set_secRef5(self, secRef5): self.secRef5 = secRef5
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChannelFieldType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChannelFieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChannelFieldType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChannelFieldType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChannelFieldType'):
        if self.feedName is not None and 'feedName' not in already_processed:
            already_processed.add('feedName')
            outfile.write(' feedName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.feedName), input_name='feedName')), ))
        if self.jobName is not None and 'jobName' not in already_processed:
            already_processed.add('jobName')
            outfile.write(' jobName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.jobName), input_name='jobName')), ))
        if self.ref1 is not None and 'ref1' not in already_processed:
            already_processed.add('ref1')
            outfile.write(' ref1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref1), input_name='ref1')), ))
        if self.ref2 is not None and 'ref2' not in already_processed:
            already_processed.add('ref2')
            outfile.write(' ref2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref2), input_name='ref2')), ))
        if self.ref3 is not None and 'ref3' not in already_processed:
            already_processed.add('ref3')
            outfile.write(' ref3=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref3), input_name='ref3')), ))
        if self.ref4 is not None and 'ref4' not in already_processed:
            already_processed.add('ref4')
            outfile.write(' ref4=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref4), input_name='ref4')), ))
        if self.ref5 is not None and 'ref5' not in already_processed:
            already_processed.add('ref5')
            outfile.write(' ref5=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ref5), input_name='ref5')), ))
        if self.secRef1 is not None and 'secRef1' not in already_processed:
            already_processed.add('secRef1')
            outfile.write(' secRef1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef1), input_name='secRef1')), ))
        if self.secRef2 is not None and 'secRef2' not in already_processed:
            already_processed.add('secRef2')
            outfile.write(' secRef2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef2), input_name='secRef2')), ))
        if self.secRef3 is not None and 'secRef3' not in already_processed:
            already_processed.add('secRef3')
            outfile.write(' secRef3=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef3), input_name='secRef3')), ))
        if self.secRef4 is not None and 'secRef4' not in already_processed:
            already_processed.add('secRef4')
            outfile.write(' secRef4=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef4), input_name='secRef4')), ))
        if self.secRef5 is not None and 'secRef5' not in already_processed:
            already_processed.add('secRef5')
            outfile.write(' secRef5=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.secRef5), input_name='secRef5')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChannelFieldType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('feedName', node)
        if value is not None and 'feedName' not in already_processed:
            already_processed.add('feedName')
            self.feedName = value
        value = find_attr_value_('jobName', node)
        if value is not None and 'jobName' not in already_processed:
            already_processed.add('jobName')
            self.jobName = value
        value = find_attr_value_('ref1', node)
        if value is not None and 'ref1' not in already_processed:
            already_processed.add('ref1')
            self.ref1 = value
        value = find_attr_value_('ref2', node)
        if value is not None and 'ref2' not in already_processed:
            already_processed.add('ref2')
            self.ref2 = value
        value = find_attr_value_('ref3', node)
        if value is not None and 'ref3' not in already_processed:
            already_processed.add('ref3')
            self.ref3 = value
        value = find_attr_value_('ref4', node)
        if value is not None and 'ref4' not in already_processed:
            already_processed.add('ref4')
            self.ref4 = value
        value = find_attr_value_('ref5', node)
        if value is not None and 'ref5' not in already_processed:
            already_processed.add('ref5')
            self.ref5 = value
        value = find_attr_value_('secRef1', node)
        if value is not None and 'secRef1' not in already_processed:
            already_processed.add('secRef1')
            self.secRef1 = value
        value = find_attr_value_('secRef2', node)
        if value is not None and 'secRef2' not in already_processed:
            already_processed.add('secRef2')
            self.secRef2 = value
        value = find_attr_value_('secRef3', node)
        if value is not None and 'secRef3' not in already_processed:
            already_processed.add('secRef3')
            self.secRef3 = value
        value = find_attr_value_('secRef4', node)
        if value is not None and 'secRef4' not in already_processed:
            already_processed.add('secRef4')
            self.secRef4 = value
        value = find_attr_value_('secRef5', node)
        if value is not None and 'secRef5' not in already_processed:
            already_processed.add('secRef5')
            self.secRef5 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ChannelFieldType


class ExtendedEntityCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, entity=None):
        self.original_tagname_ = None
        if entity is None:
            self.entity = []
        else:
            self.entity = entity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtendedEntityCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtendedEntityCollection.subclass:
            return ExtendedEntityCollection.subclass(*args_, **kwargs_)
        else:
            return ExtendedEntityCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def add_entity(self, value): self.entity.append(value)
    def insert_entity_at(self, index, value): self.entity.insert(index, value)
    def replace_entity_at(self, index, value): self.entity[index] = value
    def hasContent_(self):
        if (
            self.entity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExtendedEntityCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtendedEntityCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtendedEntityCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExtendedEntityCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExtendedEntityCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExtendedEntityCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for entity_ in self.entity:
            entity_.export(outfile, level, namespace_, name_='entity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entity':
            obj_ = ExtendedEntityType.factory()
            obj_.build(child_)
            self.entity.append(obj_)
            obj_.original_tagname_ = 'entity'
# end class ExtendedEntityCollection


class ExtendedEntityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, key_field=None, key_value=None, field=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.key_field = _cast(None, key_field)
        self.key_value = _cast(None, key_value)
        if field is None:
            self.field = []
        else:
            self.field = field
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtendedEntityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtendedEntityType.subclass:
            return ExtendedEntityType.subclass(*args_, **kwargs_)
        else:
            return ExtendedEntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field_at(self, index, value): self.field.insert(index, value)
    def replace_field_at(self, index, value): self.field[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_key_field(self): return self.key_field
    def set_key_field(self, key_field): self.key_field = key_field
    def get_key_value(self): return self.key_value
    def set_key_value(self, key_value): self.key_value = key_value
    def hasContent_(self):
        if (
            self.field
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExtendedEntityType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtendedEntityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtendedEntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExtendedEntityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExtendedEntityType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.key_field is not None and 'key_field' not in already_processed:
            already_processed.add('key_field')
            outfile.write(' key-field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.key_field), input_name='key-field')), ))
        if self.key_value is not None and 'key_value' not in already_processed:
            already_processed.add('key_value')
            outfile.write(' key-value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.key_value), input_name='key-value')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExtendedEntityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for field_ in self.field:
            field_.export(outfile, level, namespace_, name_='field', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('key-field', node)
        if value is not None and 'key-field' not in already_processed:
            already_processed.add('key-field')
            self.key_field = value
        value = find_attr_value_('key-value', node)
        if value is not None and 'key-value' not in already_processed:
            already_processed.add('key-value')
            self.key_value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'field':
            obj_ = ExtendedFieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
# end class ExtendedEntityType


class ExtendedFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExtendedFieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExtendedFieldType.subclass:
            return ExtendedFieldType.subclass(*args_, **kwargs_)
        else:
            return ExtendedFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExtendedFieldType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExtendedFieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtendedFieldType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExtendedFieldType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExtendedFieldType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ExtendedFieldType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExtendedFieldType


class CustomAttributeCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, customAttribute=None):
        self.original_tagname_ = None
        if customAttribute is None:
            self.customAttribute = []
        else:
            self.customAttribute = customAttribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomAttributeCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomAttributeCollection.subclass:
            return CustomAttributeCollection.subclass(*args_, **kwargs_)
        else:
            return CustomAttributeCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_customAttribute(self): return self.customAttribute
    def set_customAttribute(self, customAttribute): self.customAttribute = customAttribute
    def add_customAttribute(self, value): self.customAttribute.append(value)
    def insert_customAttribute_at(self, index, value): self.customAttribute.insert(index, value)
    def replace_customAttribute_at(self, index, value): self.customAttribute[index] = value
    def hasContent_(self):
        if (
            self.customAttribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomAttributeCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomAttributeCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomAttributeCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomAttributeCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomAttributeCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomAttributeCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for customAttribute_ in self.customAttribute:
            customAttribute_.export(outfile, level, namespace_, name_='customAttribute', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'customAttribute':
            obj_ = CustomAttributeType.factory()
            obj_.build(child_)
            self.customAttribute.append(obj_)
            obj_.original_tagname_ = 'customAttribute'
# end class CustomAttributeCollection


class CustomAttributeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.original_tagname_ = None
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomAttributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomAttributeType.subclass:
            return CustomAttributeType.subclass(*args_, **kwargs_)
        else:
            return CustomAttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomAttributeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomAttributeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomAttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomAttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomAttributeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomAttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class CustomAttributeType


class AddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, contactName=None, attention=None, email=None, phone=None, phone2=None, addressLine1=None, addressLine2=None, addressLine3=None, addressLine4=None, city=None, stateProvinceCode=None, postalCode=None, countryCode=None):
        self.original_tagname_ = None
        self.name = name
        self.contactName = contactName
        self.attention = attention
        self.email = email
        self.phone = phone
        self.phone2 = phone2
        self.addressLine1 = addressLine1
        self.addressLine2 = addressLine2
        self.addressLine3 = addressLine3
        self.addressLine4 = addressLine4
        self.city = city
        self.stateProvinceCode = stateProvinceCode
        self.postalCode = postalCode
        self.countryCode = countryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_contactName(self): return self.contactName
    def set_contactName(self, contactName): self.contactName = contactName
    def get_attention(self): return self.attention
    def set_attention(self, attention): self.attention = attention
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def get_phone2(self): return self.phone2
    def set_phone2(self, phone2): self.phone2 = phone2
    def get_addressLine1(self): return self.addressLine1
    def set_addressLine1(self, addressLine1): self.addressLine1 = addressLine1
    def get_addressLine2(self): return self.addressLine2
    def set_addressLine2(self, addressLine2): self.addressLine2 = addressLine2
    def get_addressLine3(self): return self.addressLine3
    def set_addressLine3(self, addressLine3): self.addressLine3 = addressLine3
    def get_addressLine4(self): return self.addressLine4
    def set_addressLine4(self, addressLine4): self.addressLine4 = addressLine4
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_stateProvinceCode(self): return self.stateProvinceCode
    def set_stateProvinceCode(self, stateProvinceCode): self.stateProvinceCode = stateProvinceCode
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_countryCode(self): return self.countryCode
    def set_countryCode(self, countryCode): self.countryCode = countryCode
    def hasContent_(self):
        if (
            self.name is not None or
            self.contactName is not None or
            self.attention is not None or
            self.email is not None or
            self.phone is not None or
            self.phone2 is not None or
            self.addressLine1 is not None or
            self.addressLine2 is not None or
            self.addressLine3 is not None or
            self.addressLine4 is not None or
            self.city is not None or
            self.stateProvinceCode is not None or
            self.postalCode is not None or
            self.countryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.contactName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontactName>%s</%scontactName>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.contactName), input_name='contactName')), namespace_, eol_))
        if self.attention is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattention>%s</%sattention>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.attention), input_name='attention')), namespace_, eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespace_, eol_))
        if self.phone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphone>%s</%sphone>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.phone), input_name='phone')), namespace_, eol_))
        if self.phone2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphone2>%s</%sphone2>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.phone2), input_name='phone2')), namespace_, eol_))
        if self.addressLine1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddressLine1>%s</%saddressLine1>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.addressLine1), input_name='addressLine1')), namespace_, eol_))
        if self.addressLine2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddressLine2>%s</%saddressLine2>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.addressLine2), input_name='addressLine2')), namespace_, eol_))
        if self.addressLine3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddressLine3>%s</%saddressLine3>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.addressLine3), input_name='addressLine3')), namespace_, eol_))
        if self.addressLine4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddressLine4>%s</%saddressLine4>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.addressLine4), input_name='addressLine4')), namespace_, eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), namespace_, eol_))
        if self.stateProvinceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstateProvinceCode>%s</%sstateProvinceCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.stateProvinceCode), input_name='stateProvinceCode')), namespace_, eol_))
        if self.postalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostalCode>%s</%spostalCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), namespace_, eol_))
        if self.countryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountryCode>%s</%scountryCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.countryCode), input_name='countryCode')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'contactName':
            contactName_ = child_.text
            contactName_ = self.gds_validate_string(contactName_, node, 'contactName')
            self.contactName = contactName_
        elif nodeName_ == 'attention':
            attention_ = child_.text
            attention_ = self.gds_validate_string(attention_, node, 'attention')
            self.attention = attention_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
        elif nodeName_ == 'phone':
            phone_ = child_.text
            phone_ = self.gds_validate_string(phone_, node, 'phone')
            self.phone = phone_
        elif nodeName_ == 'phone2':
            phone2_ = child_.text
            phone2_ = self.gds_validate_string(phone2_, node, 'phone2')
            self.phone2 = phone2_
        elif nodeName_ == 'addressLine1':
            addressLine1_ = child_.text
            addressLine1_ = self.gds_validate_string(addressLine1_, node, 'addressLine1')
            self.addressLine1 = addressLine1_
        elif nodeName_ == 'addressLine2':
            addressLine2_ = child_.text
            addressLine2_ = self.gds_validate_string(addressLine2_, node, 'addressLine2')
            self.addressLine2 = addressLine2_
        elif nodeName_ == 'addressLine3':
            addressLine3_ = child_.text
            addressLine3_ = self.gds_validate_string(addressLine3_, node, 'addressLine3')
            self.addressLine3 = addressLine3_
        elif nodeName_ == 'addressLine4':
            addressLine4_ = child_.text
            addressLine4_ = self.gds_validate_string(addressLine4_, node, 'addressLine4')
            self.addressLine4 = addressLine4_
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
        elif nodeName_ == 'stateProvinceCode':
            stateProvinceCode_ = child_.text
            stateProvinceCode_ = self.gds_validate_string(stateProvinceCode_, node, 'stateProvinceCode')
            self.stateProvinceCode = stateProvinceCode_
        elif nodeName_ == 'postalCode':
            postalCode_ = child_.text
            postalCode_ = self.gds_validate_string(postalCode_, node, 'postalCode')
            self.postalCode = postalCode_
        elif nodeName_ == 'countryCode':
            countryCode_ = child_.text
            countryCode_ = self.gds_validate_string(countryCode_, node, 'countryCode')
            self.countryCode = countryCode_
# end class AddressType


class FreightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, termsType=None, account=None, billToPartner=None, billToAddress=None):
        self.original_tagname_ = None
        self.termsType = termsType
        self.validate_termsTypeType(self.termsType)
        self.account = account
        self.billToPartner = billToPartner
        self.billToAddress = billToAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightType.subclass:
            return FreightType.subclass(*args_, **kwargs_)
        else:
            return FreightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_termsType(self): return self.termsType
    def set_termsType(self, termsType): self.termsType = termsType
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def get_billToPartner(self): return self.billToPartner
    def set_billToPartner(self, billToPartner): self.billToPartner = billToPartner
    def get_billToAddress(self): return self.billToAddress
    def set_billToAddress(self, billToAddress): self.billToAddress = billToAddress
    def validate_termsTypeType(self, value):
        # Validate type termsTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Prepaid', 'Collect', 'Third Party']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on termsTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.termsType is not None or
            self.account is not None or
            self.billToPartner is not None or
            self.billToAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FreightType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FreightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FreightType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FreightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.termsType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stermsType>%s</%stermsType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.termsType), input_name='termsType')), namespace_, eol_))
        if self.account is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccount>%s</%saccount>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.account), input_name='account')), namespace_, eol_))
        if self.billToPartner is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbillToPartner>%s</%sbillToPartner>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.billToPartner), input_name='billToPartner')), namespace_, eol_))
        if self.billToAddress is not None:
            self.billToAddress.export(outfile, level, namespace_, name_='billToAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'termsType':
            termsType_ = child_.text
            termsType_ = self.gds_validate_string(termsType_, node, 'termsType')
            self.termsType = termsType_
            # validate type termsTypeType
            self.validate_termsTypeType(self.termsType)
        elif nodeName_ == 'account':
            account_ = child_.text
            account_ = self.gds_validate_string(account_, node, 'account')
            self.account = account_
        elif nodeName_ == 'billToPartner':
            billToPartner_ = child_.text
            billToPartner_ = self.gds_validate_string(billToPartner_, node, 'billToPartner')
            self.billToPartner = billToPartner_
        elif nodeName_ == 'billToAddress':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.billToAddress = obj_
            obj_.original_tagname_ = 'billToAddress'
# end class FreightType


class NoteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source='Internal', title=None, body=None):
        self.original_tagname_ = None
        self.source = source
        self.validate_sourceType(self.source)
        self.title = title
        self.body = body
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoteType.subclass:
            return NoteType.subclass(*args_, **kwargs_)
        else:
            return NoteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_body(self): return self.body
    def set_body(self, body): self.body = body
    def validate_sourceType(self, value):
        # Validate type sourceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Internal', 'External']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on sourceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.source != "Internal" or
            self.title is not None or
            self.body is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NoteType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NoteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NoteType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NoteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source != "Internal":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespace_, eol_))
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
        if self.body is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbody>%s</%sbody>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.body), input_name='body')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
            # validate type sourceType
            self.validate_sourceType(self.source)
        elif nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'body':
            body_ = child_.text
            body_ = self.gds_validate_string(body_, node, 'body')
            self.body = body_
# end class NoteType


class NoteCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, note=None):
        self.original_tagname_ = None
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoteCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoteCollection.subclass:
            return NoteCollection.subclass(*args_, **kwargs_)
        else:
            return NoteCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note_at(self, index, value): self.note.insert(index, value)
    def replace_note_at(self, index, value): self.note[index] = value
    def hasContent_(self):
        if (
            self.note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NoteCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoteCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoteCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NoteCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NoteCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NoteCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.note.append(obj_)
            obj_.original_tagname_ = 'note'
# end class NoteCollection


class LinkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rel=None, href=None, type_=None):
        self.original_tagname_ = None
        self.rel = rel
        self.href = href
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.rel is not None or
            self.href is not None or
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srel>%s</%srel>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.rel), input_name='rel')), namespace_, eol_))
        if self.href is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shref>%s</%shref>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.href), input_name='href')), namespace_, eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rel':
            rel_ = child_.text
            rel_ = self.gds_validate_string(rel_, node, 'rel')
            self.rel = rel_
        elif nodeName_ == 'href':
            href_ = child_.text
            href_ = self.gds_validate_string(href_, node, 'href')
            self.href = href_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
# end class LinkType


class UPCCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, upc=None, source=None):
        self.original_tagname_ = None
        if upc is None:
            self.upc = []
        else:
            self.upc = upc
        self.source = source
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UPCCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UPCCollection.subclass:
            return UPCCollection.subclass(*args_, **kwargs_)
        else:
            return UPCCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_upc(self): return self.upc
    def set_upc(self, upc): self.upc = upc
    def add_upc(self, value): self.upc.append(value)
    def insert_upc_at(self, index, value): self.upc.insert(index, value)
    def replace_upc_at(self, index, value): self.upc[index] = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def hasContent_(self):
        if (
            self.upc or
            self.source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UPCCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UPCCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UPCCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UPCCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UPCCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UPCCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for upc_ in self.upc:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supc>%s</%supc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(upc_), input_name='upc')), namespace_, eol_))
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'upc':
            upc_ = child_.text
            upc_ = self.gds_validate_string(upc_, node, 'upc')
            self.upc.append(upc_)
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
# end class UPCCollection


class ItemVendorCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, itemVendor=None):
        self.original_tagname_ = None
        if itemVendor is None:
            self.itemVendor = []
        else:
            self.itemVendor = itemVendor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemVendorCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemVendorCollection.subclass:
            return ItemVendorCollection.subclass(*args_, **kwargs_)
        else:
            return ItemVendorCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_itemVendor(self): return self.itemVendor
    def set_itemVendor(self, itemVendor): self.itemVendor = itemVendor
    def add_itemVendor(self, value): self.itemVendor.append(value)
    def insert_itemVendor_at(self, index, value): self.itemVendor.insert(index, value)
    def replace_itemVendor_at(self, index, value): self.itemVendor[index] = value
    def hasContent_(self):
        if (
            self.itemVendor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ItemVendorCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemVendorCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ItemVendorCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ItemVendorCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ItemVendorCollection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ItemVendorCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for itemVendor_ in self.itemVendor:
            itemVendor_.export(outfile, level, namespace_, name_='itemVendor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'itemVendor':
            obj_ = ItemVendorType.factory()
            obj_.build(child_)
            self.itemVendor.append(obj_)
            obj_.original_tagname_ = 'itemVendor'
# end class ItemVendorCollection


class ItemVendorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, businessUnit=None, itemNumber=None, item=None, shortDescription=None, longDescription=None, tradingPartnerCode=None, reorderQuantity=None, reorderPoint=None, reorderLeadTime=None, unitCost=None, fulfillmentType=None, isPreferred=None, isInventorySyncEnabled=None, itemSkuUpc=None, additionalCost=None, quantity=None, importReference1=None, importReference2=None, reorderLot=None):
        self.original_tagname_ = None
        self.businessUnit = businessUnit
        self.itemNumber = itemNumber
        self.item = item
        self.shortDescription = shortDescription
        self.longDescription = longDescription
        self.tradingPartnerCode = tradingPartnerCode
        self.reorderQuantity = reorderQuantity
        self.reorderPoint = reorderPoint
        self.reorderLeadTime = reorderLeadTime
        self.unitCost = unitCost
        self.fulfillmentType = fulfillmentType
        self.isPreferred = isPreferred
        self.isInventorySyncEnabled = isInventorySyncEnabled
        self.itemSkuUpc = itemSkuUpc
        self.additionalCost = additionalCost
        self.quantity = quantity
        self.importReference1 = importReference1
        self.importReference2 = importReference2
        self.reorderLot = reorderLot
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemVendorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemVendorType.subclass:
            return ItemVendorType.subclass(*args_, **kwargs_)
        else:
            return ItemVendorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_businessUnit(self): return self.businessUnit
    def set_businessUnit(self, businessUnit): self.businessUnit = businessUnit
    def get_itemNumber(self): return self.itemNumber
    def set_itemNumber(self, itemNumber): self.itemNumber = itemNumber
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def get_shortDescription(self): return self.shortDescription
    def set_shortDescription(self, shortDescription): self.shortDescription = shortDescription
    def get_longDescription(self): return self.longDescription
    def set_longDescription(self, longDescription): self.longDescription = longDescription
    def get_tradingPartnerCode(self): return self.tradingPartnerCode
    def set_tradingPartnerCode(self, tradingPartnerCode): self.tradingPartnerCode = tradingPartnerCode
    def get_reorderQuantity(self): return self.reorderQuantity
    def set_reorderQuantity(self, reorderQuantity): self.reorderQuantity = reorderQuantity
    def get_reorderPoint(self): return self.reorderPoint
    def set_reorderPoint(self, reorderPoint): self.reorderPoint = reorderPoint
    def get_reorderLeadTime(self): return self.reorderLeadTime
    def set_reorderLeadTime(self, reorderLeadTime): self.reorderLeadTime = reorderLeadTime
    def get_unitCost(self): return self.unitCost
    def set_unitCost(self, unitCost): self.unitCost = unitCost
    def get_fulfillmentType(self): return self.fulfillmentType
    def set_fulfillmentType(self, fulfillmentType): self.fulfillmentType = fulfillmentType
    def get_isPreferred(self): return self.isPreferred
    def set_isPreferred(self, isPreferred): self.isPreferred = isPreferred
    def get_isInventorySyncEnabled(self): return self.isInventorySyncEnabled
    def set_isInventorySyncEnabled(self, isInventorySyncEnabled): self.isInventorySyncEnabled = isInventorySyncEnabled
    def get_itemSkuUpc(self): return self.itemSkuUpc
    def set_itemSkuUpc(self, itemSkuUpc): self.itemSkuUpc = itemSkuUpc
    def get_additionalCost(self): return self.additionalCost
    def set_additionalCost(self, additionalCost): self.additionalCost = additionalCost
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def get_importReference1(self): return self.importReference1
    def set_importReference1(self, importReference1): self.importReference1 = importReference1
    def get_importReference2(self): return self.importReference2
    def set_importReference2(self, importReference2): self.importReference2 = importReference2
    def get_reorderLot(self): return self.reorderLot
    def set_reorderLot(self, reorderLot): self.reorderLot = reorderLot
    def hasContent_(self):
        if (
            self.businessUnit is not None or
            self.itemNumber is not None or
            self.item is not None or
            self.shortDescription is not None or
            self.longDescription is not None or
            self.tradingPartnerCode is not None or
            self.reorderQuantity is not None or
            self.reorderPoint is not None or
            self.reorderLeadTime is not None or
            self.unitCost is not None or
            self.fulfillmentType is not None or
            self.isPreferred is not None or
            self.isInventorySyncEnabled is not None or
            self.itemSkuUpc is not None or
            self.additionalCost is not None or
            self.quantity is not None or
            self.importReference1 is not None or
            self.importReference2 is not None or
            self.reorderLot is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ItemVendorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemVendorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ItemVendorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ItemVendorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ItemVendorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ItemVendorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.businessUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbusinessUnit>%s</%sbusinessUnit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.businessUnit), input_name='businessUnit')), namespace_, eol_))
        if self.itemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sitemNumber>%s</%sitemNumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.itemNumber), input_name='itemNumber')), namespace_, eol_))
        if self.item is not None:
            self.item.export(outfile, level, namespace_, name_='item', pretty_print=pretty_print)
        if self.shortDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortDescription>%s</%sshortDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.shortDescription), input_name='shortDescription')), namespace_, eol_))
        if self.longDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongDescription>%s</%slongDescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.longDescription), input_name='longDescription')), namespace_, eol_))
        if self.tradingPartnerCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stradingPartnerCode>%s</%stradingPartnerCode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.tradingPartnerCode), input_name='tradingPartnerCode')), namespace_, eol_))
        if self.reorderQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreorderQuantity>%s</%sreorderQuantity>%s' % (namespace_, self.gds_format_integer(self.reorderQuantity, input_name='reorderQuantity'), namespace_, eol_))
        if self.reorderPoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreorderPoint>%s</%sreorderPoint>%s' % (namespace_, self.gds_format_integer(self.reorderPoint, input_name='reorderPoint'), namespace_, eol_))
        if self.reorderLeadTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreorderLeadTime>%s</%sreorderLeadTime>%s' % (namespace_, self.gds_format_integer(self.reorderLeadTime, input_name='reorderLeadTime'), namespace_, eol_))
        if self.unitCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunitCost>%s</%sunitCost>%s' % (namespace_, self.gds_format_double(self.unitCost, input_name='unitCost'), namespace_, eol_))
        if self.fulfillmentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfulfillmentType>%s</%sfulfillmentType>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.fulfillmentType), input_name='fulfillmentType')), namespace_, eol_))
        if self.isPreferred is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisPreferred>%s</%sisPreferred>%s' % (namespace_, self.gds_format_boolean(self.isPreferred, input_name='isPreferred'), namespace_, eol_))
        if self.isInventorySyncEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisInventorySyncEnabled>%s</%sisInventorySyncEnabled>%s' % (namespace_, self.gds_format_boolean(self.isInventorySyncEnabled, input_name='isInventorySyncEnabled'), namespace_, eol_))
        if self.itemSkuUpc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sitemSkuUpc>%s</%sitemSkuUpc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.itemSkuUpc), input_name='itemSkuUpc')), namespace_, eol_))
        if self.additionalCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadditionalCost>%s</%sadditionalCost>%s' % (namespace_, self.gds_format_double(self.additionalCost, input_name='additionalCost'), namespace_, eol_))
        if self.quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squantity>%s</%squantity>%s' % (namespace_, self.gds_format_integer(self.quantity, input_name='quantity'), namespace_, eol_))
        if self.importReference1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simportReference1>%s</%simportReference1>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.importReference1), input_name='importReference1')), namespace_, eol_))
        if self.importReference2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simportReference2>%s</%simportReference2>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.importReference2), input_name='importReference2')), namespace_, eol_))
        if self.reorderLot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreorderLot>%s</%sreorderLot>%s' % (namespace_, self.gds_format_integer(self.reorderLot, input_name='reorderLot'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'businessUnit':
            businessUnit_ = child_.text
            businessUnit_ = self.gds_validate_string(businessUnit_, node, 'businessUnit')
            self.businessUnit = businessUnit_
        elif nodeName_ == 'itemNumber':
            itemNumber_ = child_.text
            itemNumber_ = self.gds_validate_string(itemNumber_, node, 'itemNumber')
            self.itemNumber = itemNumber_
        elif nodeName_ == 'item':
            obj_ = ItemType.factory()
            obj_.build(child_)
            self.item = obj_
            obj_.original_tagname_ = 'item'
        elif nodeName_ == 'shortDescription':
            shortDescription_ = child_.text
            shortDescription_ = self.gds_validate_string(shortDescription_, node, 'shortDescription')
            self.shortDescription = shortDescription_
        elif nodeName_ == 'longDescription':
            longDescription_ = child_.text
            longDescription_ = self.gds_validate_string(longDescription_, node, 'longDescription')
            self.longDescription = longDescription_
        elif nodeName_ == 'tradingPartnerCode':
            tradingPartnerCode_ = child_.text
            tradingPartnerCode_ = self.gds_validate_string(tradingPartnerCode_, node, 'tradingPartnerCode')
            self.tradingPartnerCode = tradingPartnerCode_
        elif nodeName_ == 'reorderQuantity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reorderQuantity')
            self.reorderQuantity = ival_
        elif nodeName_ == 'reorderPoint':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reorderPoint')
            self.reorderPoint = ival_
        elif nodeName_ == 'reorderLeadTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reorderLeadTime')
            self.reorderLeadTime = ival_
        elif nodeName_ == 'unitCost':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'unitCost')
            self.unitCost = fval_
        elif nodeName_ == 'fulfillmentType':
            fulfillmentType_ = child_.text
            fulfillmentType_ = self.gds_validate_string(fulfillmentType_, node, 'fulfillmentType')
            self.fulfillmentType = fulfillmentType_
        elif nodeName_ == 'isPreferred':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isPreferred')
            self.isPreferred = ival_
        elif nodeName_ == 'isInventorySyncEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isInventorySyncEnabled')
            self.isInventorySyncEnabled = ival_
        elif nodeName_ == 'itemSkuUpc':
            itemSkuUpc_ = child_.text
            itemSkuUpc_ = self.gds_validate_string(itemSkuUpc_, node, 'itemSkuUpc')
            self.itemSkuUpc = itemSkuUpc_
        elif nodeName_ == 'additionalCost':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'additionalCost')
            self.additionalCost = fval_
        elif nodeName_ == 'quantity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'quantity')
            self.quantity = ival_
        elif nodeName_ == 'importReference1':
            importReference1_ = child_.text
            importReference1_ = self.gds_validate_string(importReference1_, node, 'importReference1')
            self.importReference1 = importReference1_
        elif nodeName_ == 'importReference2':
            importReference2_ = child_.text
            importReference2_ = self.gds_validate_string(importReference2_, node, 'importReference2')
            self.importReference2 = importReference2_
        elif nodeName_ == 'reorderLot':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reorderLot')
            self.reorderLot = ival_
# end class ItemVendorType


GDSClassesMapping = {
    'billToAddress': AddressType,
    'boxType': BoxTypeType,
    'boxTypes': BoxTypeCollection,
    'channel': ChannelResourceFieldType,
    'channels': ChannelsCollection,
    'component': KitComponentType,
    'components': KitCollection,
    'customAttribute': CustomAttributeType,
    'customField': CustomFieldType,
    'customFields': CustomFieldCollection,
    'customMapping': CustomMapType,
    'customMappings': CustomMapCollection,
    'dimension': DimensionType,
    'entity': ExtendedEntityType,
    'extendedEntities': ExtendedEntityCollection,
    'field': ExtendedFieldType,
    'item': ItemType,
    'itemVendor': ItemVendorType,
    'itemVendors': ItemVendorCollection,
    'itemWeight': WeightType,
    'items': ItemCollection,
    'note': NoteType,
    'pack': PackType,
    'packs': PackCollection,
    'upcs': UPCCollection,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ItemCollection'
        rootClass = ItemCollection
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ItemCollection'
        rootClass = ItemCollection
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ItemCollection'
        rootClass = ItemCollection
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ItemCollection'
        rootClass = ItemCollection
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from item import *\n\n')
        sys.stdout.write('import item as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AddressType",
    "BoxTypeCollection",
    "BoxTypeType",
    "ChannelFieldType",
    "ChannelResourceFieldType",
    "ChannelsCollection",
    "ChannelsResourceCollection",
    "CustomAttributeCollection",
    "CustomAttributeType",
    "CustomFieldCollection",
    "CustomFieldType",
    "CustomMapCollection",
    "CustomMapType",
    "DimensionType",
    "ExtendedEntityCollection",
    "ExtendedEntityType",
    "ExtendedFieldType",
    "FreightType",
    "ItemCollection",
    "ItemType",
    "ItemVendorCollection",
    "ItemVendorType",
    "KitCollection",
    "KitComponentType",
    "LinkType",
    "NoteCollection",
    "NoteType",
    "PackCollection",
    "PackType",
    "UPCCollection",
    "WeightType"
]
